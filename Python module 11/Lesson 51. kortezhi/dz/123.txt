1)



Создайте два списка, в каждом из которых лежит 10 случайных букв алфавита 
(могут повторяться). Затем для каждого списка создайте словарь из пар 
«индекс — значение» и выведите оба словаря на экран.


Пример: 

Первый список: ['й', 'р', 'с', 'г', 'а', 'а', 'т', 'ж', 'е', 'к']
Второй список: ['д', 'а', 'а', 'в', 'т', 'ж', 'р', 'б', 'й', 'р']

Первый словарь: {0: 'й', 1: 'р', 2: 'с', 3: 'г', 4: 'а', 5: 'а', 6: 'т', 7: 'ж', 8: 'е', 9: 'к'}
Второй словарь: {0: 'д', 1: 'а', 2: 'а', 3: 'в', 4: 'т', 5: 'ж', 6: 'р', 7: 'б', 8: 'й', 9: 'р'}



2)



Один заказчик попросил нас написать небольшой скрипт для своих криптографических нужд.
 При этом он заранее предупредил, что скрипт должен уметь работать с 
любым итерируемым типом данных.

Напишите функцию, которая возвращает список из элементов итерируемого объекта 
(кортежа, строки, списка, словаря), у которых индекс чётный.


Пример 1:
Допустим, есть такая строка: 'О Дивный Новый мир!'
Результат: ['О', 'Д', 'в', 'ы', ' ', 'о', 'ы', ' ', 'и', '!']

Пример 2:
Допустим, есть такой список: [100, 200, 300, 'буква', 0, 2, 'а']
Результат: [100, 300, 0, 'а']

Примечание: для проверки типа можно использовать функцию 

isinstance(<элемент>, <тип данных>), которая возвращает True, если элемент принадлежит к этому типу данных, и возвращает False в противном случае.